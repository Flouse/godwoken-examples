import { Cell, core as LumosBaseCore, Hash, HexString, Script, utils as LumosUtils, WitnessArgs } from "@ckb-lumos/base";
import { CkbIndexer } from "../account/indexer-remote";
import { privateKeyToCkbAddress } from "../modules/utils";
import { core as GodwokenSchemas, normalizer } from "@godwoken-examples/godwoken";
import { normalizers, Reader } from "ckb-js-toolkit";
import { logger } from "../modules/logger";
import { deploymentConfig } from "../modules/deployment-config";
import { parseAddress, sealTransaction, TransactionSkeleton } from "@ckb-lumos/helpers";
import { privKeys } from "./accounts";
import { initConfigAndSync } from "../account/common";
import { getSudtCellDep } from "../account/unlock";
import { common as LumosCommonScripts } from "@ckb-lumos/common-scripts";
import { key as LumosHdKey } from "@ckb-lumos/hd";
import { testnetCkbIndexerURL, testnetCkbRpc, testnetCkbRpcUrl } from "../common";
import { ROLLUP_TYPE_HASH } from "../modules/godwoken-config";

async function sendUnlockTransaction(
  ckbIndexer: CkbIndexer,
  withdrawalCell: Cell,
  lockScript: Script,
  ckbAddress: string,
  privKey: string,
  sudtScript?: Script): Promise<Hash | undefined> {
  console.log("withdrawalCell:", withdrawalCell);


  // TODO: multi withdrawalCells
  const outputCell: Cell = {
    cell_output: {
      capacity: withdrawalCell.cell_output.capacity,
      lock: lockScript,
      type: withdrawalCell.cell_output.type,
    },
    data: withdrawalCell.data,
  };
  // Build UnlockWithdrawal::UnlockWithdrawalViaFinalize and put into withess
  const data = "0x00000000" + new Reader(
    GodwokenSchemas.SerializeUnlockWithdrawalViaFinalize(
      normalizer.NormalizeUnlockWithdrawalViaFinalize({})
    )
  ).serializeJson().slice(2);
  logger.debug("withdrawal_witness:", data);
  const newWitnessArgs: WitnessArgs = {
    lock: data,
  };
  const withdrawalWitness = new Reader(
    LumosBaseCore.SerializeWitnessArgs(
      normalizers.NormalizeWitnessArgs(newWitnessArgs)
    )
  ).serializeJson();

  const rollupCell = await ckbIndexer.getRollupCell();
  if (rollupCell == null) {
    console.error("[ERROR]: rollupCell not found");
    return;
  }

  let txSkeleton = TransactionSkeleton({ cellProvider: ckbIndexer });
  txSkeleton = txSkeleton
    .update("inputs", inputs => inputs.push(withdrawalCell))
    .update("outputs", outputs => outputs.push(outputCell))
    .update("cellDeps", cellDeps => cellDeps.push(deploymentConfig.withdrawal_lock_dep))
    .update("cellDeps", cellDeps => cellDeps.push({
      out_point: rollupCell.out_point!,
      dep_type: "code"
    }))
    .update("witnesses", witnesses => witnesses.push(withdrawalWitness))
    .update("fixedEntries", fixedEntries => fixedEntries.push(
      { field: "outputs", index: 0 })
    );
  
  if (!!sudtScript) {
    txSkeleton = txSkeleton.update("cellDeps",
      cellDeps => cellDeps.push(getSudtCellDep()));
  }
  txSkeleton = await LumosCommonScripts.payFeeByFeeRate(
    txSkeleton,
    [ckbAddress],
    BigInt(1000)
  );
  txSkeleton = LumosCommonScripts.prepareSigningEntries(txSkeleton);

  logger.debug("UnlockTransaction:", JSON.stringify(txSkeleton.toJS(), null, 2));
  const message: HexString = txSkeleton.get("signingEntries").get(0)!.message;
  const content: HexString = LumosHdKey.signRecoverable(message, privKey);
  const tx = sealTransaction(txSkeleton, [content]);
  logger.debug("sealTransaction.inputs:", tx.inputs);

  const txHash: Hash | undefined = await testnetCkbRpc.send_transaction(tx, "passthrough");
  console.log("UnlockTransaction Hash:", txHash);
  return txHash;
}

/**
 * To complete the withdrawal process, we should unlock the the withdrawable
 * funds generated by witdraw-request.
 */
async function unlock(
  privKey: HexString,
  ckbIndexer: CkbIndexer,
  sudtScript?: Script,
  // retryTime = 10
): Promise<boolean> {

  let rollupCell = await ckbIndexer.getRollupCell();
  if (rollupCell == null) {
    console.error("[ERROR]: rollupCell not found");
    return false;
  }

  const ckbAddress = privateKeyToCkbAddress(privKey);
  console.log("CKB address:", ckbAddress);
  const lockScript = parseAddress(ckbAddress);
  const lock_script_hash = LumosUtils.computeScriptHash(lockScript);

  // const withdrawalCell: Cell = {
  //   "cell_output": {
  //     "capacity": "0x62b85e900",
  //     "lock": {
  //       "args": "0x27c8b9a5345d4004b86d5a2daa3ae44a7c261a8e3f7953fd54b1421146d043bf1ec223af780c6459dca5f359e817fb915e858afb5acb89262a9bea9fda02e4ba4b5b8fc819d663fb5f5b4766f455552a1639b593599d34510188aedeb2442d6f162400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e9852b0600000051ad8c0518d6e34f204c1130413e320b75d64239893fa00e44622bd09c1681f60000000000000000000000000000000000000000000000000000000000000000",
  //       "code_hash": "0x170ef156e9f6132dbca6069dfd3e436f7d91c29d3ac7332c4b33e633b6a299b5",
  //       "hash_type": "type"
  //     },
  //   },
  //   "data": "0x",
  //   "out_point": {
  //     "index": "0xd",
  //     "tx_hash": "0xdb8d8bf6a78396ef6d0d7b9fd205cca1d962fef13657845861f8c992e77f57f8"
  //   },
  //   "block_number": "0x38e676"
  // };
  // await sendUnlockTransaction(ckbIndexer, withdrawalCell, lockScript, ckbAddress, privKey);

  // return false;

  const globalState = new GodwokenSchemas.GlobalState(new Reader(rollupCell.data));
  const last_finalized_block_number = globalState
    .getLastFinalizedBlockNumber()
    .toLittleEndianBigUint64();
  logger.debug("last_finalized_block_number", last_finalized_block_number);

  // * search withdrawal locked cell by:
  //   - withdrawal lock code hash
  //   - owner secp256k1 blake2b160 lock hash
  //   - last_finalized_block_number
  const withdrawal_lock = deploymentConfig.withdrawal_lock;
  const withdrawalCollector = ckbIndexer.collector({
    lock: {
      code_hash: withdrawal_lock.code_hash,
      hash_type: withdrawal_lock.hash_type,
      args: ROLLUP_TYPE_HASH, // prefix search
    },
    type: sudtScript ? sudtScript : "empty",
    argsLen: "any",
    // order: "desc"
    // TODO: testnet 
    // skip: 3000000, 
  });
  console.time("searching withdrawal_cells");
  const withdrawalCells: Cell[] = [];
  let unFinalizedWithdrawalCellNum = 0;
  let stop = false;
  for await (const cell of withdrawalCollector.collect()) {
    const lock_args = cell.cell_output.lock.args;
    const withdrawal_lock_args_data = "0x" + lock_args.slice(66);
    const withdrawal_lock_args = new GodwokenSchemas.WithdrawalLockArgs(
      new Reader(withdrawal_lock_args_data)
    );
    const owner_lock_hash = new Reader(
      withdrawal_lock_args.getOwnerLockHash().raw()
    ).serializeJson();
    if (owner_lock_hash !== lock_script_hash) {
      continue;
    }

    logger.debug(`[${ckbAddress}]: withdrawalCell:`, cell);
    const withdrawal_block_number = withdrawal_lock_args
      .getWithdrawalBlockNumber()
      .toLittleEndianBigUint64();
    logger.debug("withdrawal_block_number", withdrawal_block_number);
    if (withdrawal_block_number > last_finalized_block_number) {
      logger.debug(`(${withdrawal_block_number} > ${last_finalized_block_number})
        => This withdrawal cell is not finalized.`);
      unFinalizedWithdrawalCellNum++;
      continue;
    }

    withdrawalCells.push(cell);

    // only process first one
    if (withdrawalCells.length === 1) {
      sendUnlockTransaction(ckbIndexer, cell, lockScript, ckbAddress, privKey)
        .then(() => stop = true);

      break;
    }

    if (stop) break;
  }
  console.timeEnd("searching withdrawal_cells");
  if (withdrawalCells.length === 0 && unFinalizedWithdrawalCellNum === 0) {
    console.warn(`[${ckbAddress}]: No valid withdrawal cell found`);
    return false;
  }
  console.log(
    `[${ckbAddress}] found ${withdrawalCells.length} finalized withdrawal cells
      and ${unFinalizedWithdrawalCellNum} finalized withdrawal cells`
  );

  // TODO:  retry
  return true;
}

/**
 * Enviroments:
 * GW_NET=<GodwokenNetwork>
 * DEBUG=true
 * 
 * Usage:
 * DEBUG=true GW_NET=testnet yarn ts-node src/benchmark/batch-unlock.ts [accountNum]
 */
(async () => {
  const args = process.argv.slice(2);
  const endIdx = args[0] || privKeys.length;
  console.log(`\t Using accounts[0..${endIdx}]`);

  console.log("process.env.GW_NET", process.env.GW_NET);
  const ckbIndexer = await initConfigAndSync("https://testnet.ckb.dev/rpc", "https://testnet.ckb.dev/indexer");
  // ### Node RPC
  // - CKB2021: https://testnet.ckbapp.dev/rpc
  // - https://testnet.ckb.dev/
  // - https://testnet.ckb.dev/rpc
  
  // ### Indexer RPC
  // - CKB2021: https://testnet.ckbapp.dev/indexer
  // - https://testnet.ckb.dev/indexer


  // TODO: GW_NET
  unlock(privKeys[764], ckbIndexer);



})();